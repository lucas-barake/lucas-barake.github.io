---
title: The RBAC Mistake Everyone Makes - ACLs in TypeScript & Effect
date: 2025-03-04
description: "One of the main challenges I've faced when using TanStack is achieving offline usage while having full control over the data layer. In this blog post, we'll explore how to use Effect and Effect Schema, along with the browser's IndexedDB, to persist TanStack Query data locally."
---

I've seen a lot of apps tie authorization logic directly to roles. Like, `if user.role == 'admin'`, grant access.

But here's the problem: roles are just labels. RBAC (Role-Based Access Control) is about grouping permissions into roles like 'Admin' or 'Moderator'. However, roles themselves aren't actionable—they're simply buckets of permissions.

So why do we use roles at all? Because humans aren't great at managing dozens of individual permissions. Roles simplify permission management for us. But in code, directly checking roles is problematic. If you hardcode role checks, you'll soon find yourself maintaining a tangled mess of conditional statements every time roles evolve.

That's where ACLs (Access Control Lists) come into play. An ACL is essentially a list of specific permissions assigned directly to a user. Instead of asking, "Is this user an Admin?", you ask, "Does this user have the `user:delete` permission?"

Think of roles as a UI layer—how humans organize and manage permissions—while permissions themselves are the actual source of truth your code enforces.

## Typing Permissions

So, what's the better approach? First, we need a strongly-typed foundation for our permissions. Instead of loose string checks scattered throughout our codebase, we'll create a type-safe permission system.

Here's the first piece of the puzzle—a TypeScript utility to generate our permissions:

```typescript
type PermissionAction = "read" | "manage" | "delete";
type PermissionConfig = Record<string, ReadonlyArray<PermissionAction>>;

type InferPermissions<T extends PermissionConfig> = {
  [K in keyof T]: T[K][number] extends PermissionAction
    ? `${K & string}:${T[K][number]}`
    : never;
}[keyof T];

export const makePermissions = <T extends PermissionConfig>(
  config: T
): Array<InferPermissions<T>> => {
  return Object.entries(config).flatMap(([domain, actions]) =>
    actions.map((action) => `${domain}:${action}` as InferPermissions<T>)
  );
};
```

What's happening here? We're creating a type-safe way to generate permission strings in a consistent format: `domain:action`. The magic lies in the `InferPermissions` type, which generates a union of all possible permission combinations based on our configuration.

Now, instead of random string literals scattered throughout our code, we define our application's permissions clearly in one place:

```ts
import * as internal from "./internal/policy.js";

const Permissions = internal.makePermissions({
  posts: ["read", "manage", "delete"],
  comments: ["read", "manage"]
} as const);
```

Notice how we've explicitly defined that users can read, manage, and delete posts, but only read and manage comments—deletion isn't supported. Our type system now accurately reflects our business rules.

This becomes our single source of truth. We can even use it to create a Schema:

```ts
export const Permission = Schema.Literal(...Permissions).annotations({
  identifier: "Permission"
});
export type Permission = typeof Permission.Type;
```

Now we have a `Permission` type that's exactly the union of `"posts:read" | "posts:manage" | "posts:delete" | "comments:read" | "comments:manage"`. The compiler will immediately alert you if you attempt to check for `"comments:delete"`—a permission that doesn't exist.

## Context: Making User Permissions Available

With our permissions strongly typed, we need a way to access them throughout our application. Since we're using Effect, its context system is perfect for this:

```typescript
import * as Context from "effect/Context";
import * as HttpApiMiddleware from "@effect/platform/HttpApiMiddleware";
import * as CustomHttpApiError from "./CustomHttpApiError.js";

export class CurrentUser extends Context.Tag("CurrentUser")
  CurrentUser,
  {
    readonly sessionId: string;
    readonly userId: UserId;
    readonly permissions: Set<Permission>;
  }
>() {}

export class UserAuthMiddleware extends HttpApiMiddleware.Tag<UserAuthMiddleware>()(
  "UserAuthMiddleware",
  {
    failure: CustomHttpApiError.Unauthorized,
    provides: CurrentUser,
  },
) {}
```

The idea is to leverage Effect's `R` type parameter so we can access the user context anywhere down the pipe. Since I'm using Effect's Platform HttpApi module, I define a simple context that my auth middleware will provide.

For demonstration purposes, this `CurrentUser` context just contains a `sessionId`, `userId`, and `permissions` which is a `Set<Permission>`. In your actual authentication middleware implementation, you'd populate these permissions from decoding a JWT, a database lookup, a Redis cache, or whatever your system uses.

Once provided by the `UserAuthMiddleware`, the `CurrentUser` context becomes available to any Effect that requires it - no matter how deep in your call stack. This is dependency injection on steroids, with full type safety.

## A Simple Implementation Example

To give you a concrete idea of how this works, here's a simple live implementation with a mock constant context:

```typescript
import * as Schema from "effect/Schema";
import * as Layer from "effect/Layer;
import * as Effect from "effect/Effect"
import { constant } from "effect/Function";
import * as Policy from "@org/domain/Policy";

const CurrentUserSchema = Schema.Struct({
  sessionId: Schema.String,
  userId: UserId,
  permissions: Schema.Set(Policy.Permission),
});

export const UserAuthMiddlewareLive = Layer.effect(
  Policy.UserAuthMiddleware,
  Effect.sync(
    constant(
      // here you'd replace this with code that
      // extracts tokens from request headers,
      // validates them, and loads the appropriate
      // permissions for that user
      Effect.succeed(
        CurrentUserSchema.make({
          sessionId: "sim_12345678",
          userId: UserId.make("user_12345678"),
          permissions: new Set(["posts:read", "comments:read"]),
        }),
      ),
    ),
  ),
);
```

## ACL Guards: Enforcing Permissions in Practice

Now that we have our permission system and context in place, let's build the actual guards that enforce access control:

```ts
/**
 * Protects an effect by checking if the current user has the required permission.
 * If the user doesn't have the permission, fails with Forbidden error.
 */
export const withPermission = (requiredPermission: Permission) => {
  return <A, E, R>(
    self: Effect.Effect<A, E, R>
  ): Effect.Effect<A, E | CustomHttpApiError.Forbidden, R | CurrentUser> =>
    Effect.zipRight(
      CurrentUser.pipe(
        Effect.flatMap((user) =>
          user.permissions.has(requiredPermission)
            ? Effect.void
            : new CustomHttpApiError.Forbidden()
        )
      ),
      self
    );
};
```

Let's break this down. The `withPermission` function takes a required permission and returns a function that wraps any Effect to protect it. Inside, we use `Effect.zipRight` which runs two effects in sequence - first the permission check, then your original effect. It discards the output of the first effect (so the permission check in this case) and gives us the result of the original effect (`self`).

The permission check grabs the `CurrentUser` from context, then checks if the user has the required permission in their permissions set. If they do, we proceed with a `void` effect. If not, we fail with a `Forbidden` error, which short-circuits execution and prevents your protected effect from running at all.

Building on this foundation, we can create more sophisticated permission checks:

```ts
/**
 * Protects an effect by checking if the current user has any of the required permissions.
 * If the user doesn't have any of the permissions, fails with Forbidden error.
 */
export const withPermissionAny = (
  requiredPermissions: NonEmptyReadonlyArray<Permission>
) => {
  return <A, E, R>(
    self: Effect.Effect<A, E, R>
  ): Effect.Effect<A, E | CustomHttpApiError.Forbidden, R | CurrentUser> =>
    Effect.zipRight(
      CurrentUser.pipe(
        Effect.flatMap((user) =>
          requiredPermissions.some((permission) =>
            user.permissions.has(permission)
          )
            ? Effect.void
            : new CustomHttpApiError.Forbidden()
        )
      ),
      self
    );
};

/**
 * Protects an effect by checking if the current user has all the required permissions.
 * If the user doesn't have all permissions, fails with Forbidden error.
 */
export const withPermissionAll = (
  requiredPermissions: NonEmptyReadonlyArray<Permission>
) => {
  return <A, E, R>(
    self: Effect.Effect<A, E, R>
  ): Effect.Effect<A, E | CustomHttpApiError.Forbidden, R | CurrentUser> =>
    Effect.zipRight(
      CurrentUser.pipe(
        Effect.flatMap((user) =>
          requiredPermissions.every((permission) =>
            user.permissions.has(permission)
          )
            ? Effect.void
            : new CustomHttpApiError.Forbidden()
        )
      ),
      self
    );
};
```

These helpers give us fine-grained control over permission requirements. `withPermissionAny` allows access if the user has at least one of the specified permissions, while `withPermissionAll` requires all permissions to be present.

With these guards in place, we can now protect any Effect-based operation in our application. Here's how it looks in practice:

```ts
import { describe, it } from "@effect/vitest";
import { deepStrictEqual } from "assert";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Layer from "effect/Layer";
import { UserId } from "../src/EntityIds.js";
import * as Policy from "../src/Policy.js";

const mockUser = (
  perms: Array<Policy.Permission>
): Policy.CurrentUser["Type"] =>
  ({
    sessionId: "test-session",
    userId: UserId.make("test-user"),
    permissions: new Set(perms)
  }) as const;

const provideCurrentUser = (perms: Array<Policy.Permission>) =>
  Effect.provide(Layer.succeed(Policy.CurrentUser, mockUser(perms)));

it.effect("denies access when user doesn't have required permission", () =>
  Effect.gen(function* () {
    const result = yield* Effect.succeed("allowed").pipe(
      Policy.withPermission("comments:manage"),
      Effect.exit
    );

    deepStrictEqual(Exit.isFailure(result), true);
  }).pipe(provideCurrentUser(["comments:read"]))
);
```

The great thing about this approach, thanks to Effect's composition, is that you can write all your logic upfront and then add permission guards where needed when piping through your computations. This separation of concerns makes your code easier to reason about - first you focus on business logic, then you layer in permission checks.

🚨 For optimal control flow, place these guards as the last step in your pipeline chain to ensure they're evaluated first in the actual execution flow, letting you fail fast before any expensive operations run.

## ABAC: Attribute-Based Access Control

Now that we've covered basic permission checking, let's tackle more complex scenarios with ABAC (Attribute-Based Access Control). ABAC shines when you need to make access decisions based on the relationship between the user and the resource - like "is this user the owner of this post?" or "is this user an admin of this forum?"

Here's how we implement ABAC policies:

```ts
/**
 * Represents an access policy that can be evaluated against the current user.
 * A policy is a function that returns Effect.void if access is granted,
 * or fails with a CustomHttpApiError.Forbidden if access is denied.
 */
type Policy<E, R> = Effect.Effect<
  void,
  CustomHttpApiError.Forbidden | E,
  CurrentUser | R
>;

/**
 * Creates a policy from a predicate function that evaluates the current user.
 */
export const policy = <E, R>(
  predicate: (user: CurrentUser["Type"]) => Effect.Effect<boolean, E, R>
): Policy<E, R> =>
  CurrentUser.pipe(
    Effect.flatMap((user) =>
      Effect.flatMap(predicate(user), (result) =>
        result ? Effect.void : new CustomHttpApiError.Forbidden()
      )
    )
  );
```

The core idea is to represent a policy as an Effect that either succeeds with `void` (access granted) or fails with `Forbidden` (access denied). The `policy` function creates this Effect from a predicate that takes the current user and returns a boolean Effect.

This approach gives us amazing flexibility - the predicate can perform any check, including database lookups to verify relationships between users and resources.

Just like with our permission guards, we can wrap Effects with policy checks:

```ts
/**
 * Applies a predicate as a pre-check to an effect.
 * If the predicate returns false, the effect will fail with Forbidden.
 */
export const withPolicy =
  <E, R>(policy: Policy<E, R>) =>
  <A, E2, R2>(self: Effect.Effect<A, E2, R2>) =>
    Effect.zipRight(policy, self);
```

And we can compose policies with AND/OR semantics:

```ts
/**
 * Combines multiple policies with AND semantics - all must pass.
 */
export const withPolicyAll =
  <A, E, R>(policies: NonEmptyReadonlyArray<Policy<E, R>>) =>
  (self: Effect.Effect<A, E, R>) =>
    Effect.zipRight(
      Effect.all(policies, {
        concurrency: 1,
        discard: true
      }),
      self
    );

/**
 * Combines multiple policies with OR semantics - at least one must pass.
 */
export const withPolicyAny =
  <A, E, R>(policies: NonEmptyReadonlyArray<Policy<E, R>>) =>
  (self: Effect.Effect<A, E, R>) =>
    Effect.zipRight(Effect.firstSuccessOf(policies), self);
```

Here's how you might use these in a test:

```ts
it.effect("denies access when policy predicate returns false", () =>
  Effect.gen(function* () {
    const result = yield* Effect.succeed("allowed").pipe(
      Policy.withPolicy(Policy.policy(() => Effect.succeed(false))),
      Effect.exit
    );

    deepStrictEqual(Exit.isFailure(result), true);
  }).pipe(provideCurrentUser([]))
);
```

For real-world usage, I recommend creating dedicated policy services for each entity type. For example, a `PostsPolicy` service might look like:

```ts
import { Database } from "@org/database";
import * as Policy from "@org/domain/Policy";
import * as Effect from "effect/Effect";
import * as Option from "effect/Option";

export class PostsRepo extends Effect.Service<PostsRepo>()("PostsRepo", {
  effect: Effect.gen(function* () {
    const db = yield* Database.Database;

    const findFirst = db.makeQuery((execute, id: string) =>
      execute((client) =>
        client.query.postsTable.findFirst({
          where: (columns, { eq }) => eq(columns.id, id)
        })
      ).pipe(Effect.flatMap(Option.fromNullable))
    );

    return {
      findFirst
    } as const;
  })
}) {}

export class PostsPolicy extends Effect.Servicethe<PostsPolicy>()(
  "PostsPolicy",
  {
    dependencies: [PostsRepo.Default],
    effect: Effect.gen(function* () {
      const postsRepo = yield* PostsRepo;

      const isOwner = (postId: string) =>
        Policy.policy((user) =>
          postsRepo
            .findFirst(postId)
            .pipe(Effect.map((post) => post.authorId === user.userId))
        );

      return {
        isOwner
      } as const;
    })
  }
) {}
```

This approach lets you define domain-specific policies that encapsulate the access control logic for each entity type.

At the controller level, you can then apply these policies:

```ts
Effect.gen(function* () {
  const postsPolicy = yield* PostsPolicy;

  const updatePost = Effect.promise(() => /* update post logic */).pipe(
    Policy.withPolicy(postsPolicy.isOwner("post-123"))
  );

  return yield* updatePost;
});
```

And with that, you've implemented ABAC in a type-safe, composable manner that integrates seamlessly with your application logic!

## Conclusion

We've covered a lot of ground in this post, from the fundamental mistake of checking roles directly to building a robust, type-safe permission system with Effect. Let's recap the key takeaways:

1. **Roles are for humans, permissions are for code** - Roles are just convenient groupings of permissions that make management easier for humans. Your code should always check for specific permissions, not roles.

2. **Type safety is your friend** - By creating a strongly-typed permission system, we catch permission errors at compile time rather than runtime. No more typos in permission strings or checking for permissions that don't exist.

3. **Composition is powerful** - Effect's functional approach lets us compose permission checks and policies in a clean, declarative way. We can combine policies with AND/OR logic and apply them to any Effect in our application.

4. **ABAC extends your capabilities** - When simple permission checks aren't enough, attribute-based policies give you the flexibility to make access decisions based on the relationship between users and resources.

The approach outlined in this post scales well with application complexity. As your authorization requirements grow, you can add new permissions and policies without changing your existing code structure.

For a complete implementation of everything we've discussed, [check out the full code in my Effect sandbox repository](https://github.com/lucas-barake/effect-sandbox/blob/main/src/domain/Policy.ts).

Remember, the goal isn't just to implement authorization, but to do it in a way that's maintainable, type-safe, and aligned with your business rules. By focusing on permissions rather than roles, and leveraging Effect's powerful abstractions, you can build an authorization system that grows with your application and keeps your code clean and maintainable.

Happy coding!
